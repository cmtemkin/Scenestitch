name: Project Sync

on:
  workflow_dispatch:
  push:
    paths:
      - .github/project-tasks.json

permissions:
  contents: read
  issues: write
  projects: write

jobs:
  sync:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Sync project tasks
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PROJECT_TOKEN }}
          script: |
            const fs = require('fs');
            const path = '.github/project-tasks.json';
            const data = JSON.parse(fs.readFileSync(path, 'utf8'));
            const { owner, number, repo, defaultStage } = data.project;
            const tasks = data.tasks || [];

            if (!owner || !number || !repo) {
              throw new Error('project.owner, project.number, and project.repo are required');
            }

            const [repoOwner, repoName] = repo.split('/');
            const defaultLabels = ['agent-task'];

            // Fetch project + fields
            const projectQuery = `
              query($login: String!, $number: Int!) {
                user(login: $login) {
                  projectV2(number: $number) {
                    id
                    title
                    fields(first: 50) {
                      nodes {
                        ... on ProjectV2SingleSelectField {
                          id
                          name
                          options { id name }
                        }
                        ... on ProjectV2FieldCommon {
                          id
                          name
                        }
                      }
                    }
                  }
                }
              }
            `;

            const projectRes = await github.graphql(projectQuery, { login: owner, number });
            const project = projectRes.user?.projectV2;
            if (!project) throw new Error(`Project ${owner}/${number} not found`);

            const stageField = project.fields.nodes.find(f => f.name === 'Stage' && f.options);
            const stageOptions = stageField ? stageField.options.reduce((acc, opt) => {
              acc[opt.name] = opt.id;
              return acc;
            }, {}) : {};

            // List all issues (state=all) to map by title
            async function listIssues() {
              let page = 1;
              const per_page = 100;
              const all = [];
              while (true) {
                const res = await github.rest.issues.listForRepo({
                  owner: repoOwner,
                  repo: repoName,
                  state: 'all',
                  per_page,
                  page
                });
                const issues = res.data.filter(i => !i.pull_request);
                all.push(...issues);
                if (res.data.length < per_page) break;
                page++;
              }
              return all;
            }

            const existingIssues = await listIssues();
            const issueByTitle = new Map(existingIssues.map(i => [i.title, i]));

            async function ensureLabels(issueNumber, labels) {
              if (!labels || labels.length === 0) return;
              await github.rest.issues.addLabels({
                owner: repoOwner,
                repo: repoName,
                issue_number: issueNumber,
                labels
              });
            }

            async function addToProject(contentId, stageName) {
              const addMutation = `
                mutation($projectId: ID!, $contentId: ID!) {
                  addProjectV2ItemById(input: { projectId: $projectId, contentId: $contentId }) {
                    item { id }
                  }
                }
              `;

              let itemId = null;
              try {
                const addRes = await github.graphql(addMutation, { projectId: project.id, contentId });
                itemId = addRes.addProjectV2ItemById?.item?.id;
              } catch (err) {
                // Item may already exist; ignore
                return;
              }

              if (!itemId || !stageField || !stageName) return;
              const optionId = stageOptions[stageName];
              if (!optionId) return;

              const updateMutation = `
                mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $optionId: String!) {
                  updateProjectV2ItemFieldValue(
                    input: {
                      projectId: $projectId,
                      itemId: $itemId,
                      fieldId: $fieldId,
                      value: { singleSelectOptionId: $optionId }
                    }
                  ) { projectV2Item { id } }
                }
              `;

              await github.graphql(updateMutation, {
                projectId: project.id,
                itemId,
                fieldId: stageField.id,
                optionId
              });
            }

            for (const task of tasks) {
              const title = task.title?.trim();
              if (!title) continue;
              const body = task.body || '';
              const labels = task.labels?.length ? task.labels : defaultLabels;
              const stage = task.stage || defaultStage || null;
              const desiredState = (task.state || 'open').toLowerCase();

              let issue = issueByTitle.get(title);

              if (!issue) {
                const created = await github.rest.issues.create({
                  owner: repoOwner,
                  repo: repoName,
                  title,
                  body,
                  labels
                });
                issue = created.data;
                issueByTitle.set(title, issue);
              } else {
                // Ensure label exists
                await ensureLabels(issue.number, labels);
                // Keep body in sync when provided
                if (body && issue.body !== body) {
                  await github.rest.issues.update({
                    owner: repoOwner,
                    repo: repoName,
                    issue_number: issue.number,
                    body
                  });
                }
              }

              // Sync issue state if requested
              if (desiredState === 'closed' && issue.state !== 'closed') {
                await github.rest.issues.update({
                  owner: repoOwner,
                  repo: repoName,
                  issue_number: issue.number,
                  state: 'closed'
                });
              }
              if (desiredState === 'open' && issue.state === 'closed') {
                await github.rest.issues.update({
                  owner: repoOwner,
                  repo: repoName,
                  issue_number: issue.number,
                  state: 'open'
                });
              }

              if (issue.node_id) {
                await addToProject(issue.node_id, stage);
              }
            }

            core.info(`Synced ${tasks.length} tasks to Project #${number}`);
